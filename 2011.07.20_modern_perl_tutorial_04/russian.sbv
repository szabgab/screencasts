0:00:01.600,0:00:04.533
Здравствуйте, и добро пожаловать на канал Учебное руководство по Perl

0:00:04.533,0:00:06.599
Сегодня я собираюсь поговорить о

0:00:06.599,0:00:08.733
некоторых функциях,

0:00:08.733,0:00:12.800
которые могут обрабатывать строки в Perl

0:00:12.800,0:00:14.768
Есть несколько базовых, как ...

0:00:14.768,0:00:16.463
Давайте перейдем к другому окну

0:00:16.463,0:00:20.932
Таким образом, есть несколько базовых функций, например

0:00:20.932,0:00:24.056
lc, которая возвращает строчную версию строки

0:00:24.056,0:00:26.423
uc, которая возвращает прописную версию

0:00:26.423,0:00:30.324
length, которая вернет число символов в данной строке

0:00:30.324,0:00:34.643
Итак, я написал пару файлов-примеров,

0:00:34.643,0:00:38.000
То, что вы можете увидеть здесь - $str, в которой

0:00:38.000,0:00:40.936
HeLlo с прописной L и строчной l

0:00:40.936,0:00:43.533
И, если мы запустим скрипт...

0:00:43.533,0:00:46.000
Давайте запустим его, чтобы вы могли видеть как все это на самом деле работает.

0:00:46.000,0:00:50.712
Мы видим что на первой строке "hello" написано строчными буквами

0:00:50.712,0:00:53.267
На второй строке - все слово прописными

0:00:53.267,0:00:57.213
И на последней строке - число букв

0:00:57.213,0:01:02.206
И ни один из них, на самом деле, не изменил строки

0:01:02.206,0:01:05.781
Если вы желаете заменить строки, тогда введите:

0:01:05.781,0:01:10.159
$str = lc $str;

0:01:10.174,0:01:13.874
и затем снова введите $str

0:01:14.951,0:01:18.374
И, если сейчас запустить скрипт, мы увидим что

0:01:18.528,0:01:21.905
$str уже строчный

0:01:23.228,0:01:25.420
Эти, на самом деле, действительно простые функции.

0:01:25.543,0:01:27.799
Существует одна чуть более сложная функция,

0:01:27.799,0:01:30.400
которая называется index

0:01:30.400,0:01:32.917
index будет нормально получать два параметра.

0:01:33.009,0:01:35.140
Один из них - строка, как эта

0:01:36.371,0:01:37.994
Давайте увеличим шрифт...

0:01:39.840,0:01:43.663
Первый параметр - строка

0:01:43.663,0:01:45.102
и это то, что вы можете увидеть здесь

0:01:45.102,0:01:48.066
и второй параметр - так же строка,

0:01:48.066,0:01:50.340
которая обычно короче

0:01:50.340,0:01:55.867
потому, что мы ищем ее местоположение в первом параметре

0:01:55.867,0:01:59.814
Итак, если мы запустим index на этом , придав ему значение "cat"

0:01:59.814,0:02:01.765
он возвратит нам 10

0:02:01.765,0:02:06.269
Потому что "cat" начинается с 10.

0:02:06.269,0:02:11.425
index считает символы начиная с 0

0:02:11.425,0:02:13.561
так, эта заглавная T на самом деле 0

0:02:13.561,0:02:17.697
и "c" - 10

0:02:17.866,0:02:22.266
Если я запущу эту же index функцию, теперь придавая значение "dog"

0:02:22.266,0:02:24.133
тогда он возвратит -1

0:02:24.133,0:02:26.667
потому что на этой строке есть только "cat"

0:02:26.667,0:02:28.793
но нет "dog"

0:02:28.793,0:02:33.236
И, при ошибке или сбое, мы получим -1

0:02:33.682,0:02:37.942
Если мы заставим функцию выдать нам строку,

0:02:37.942,0:02:42.698
не являющейся исходной, мы получим -1

0:02:43.067,0:02:45.419
Это может быть не самым удобным способом,

0:02:45.419,0:02:48.338
но это то, что мы должны использовать

0:02:49.000,0:02:55.199
Если я вызову index с параметром "The", заглавной T

0:02:55.199,0:02:56.932
Я получу 0

0:02:56.932,0:03:01.599
Это показывает, что index начинает считать символы с 0

0:03:01.599,0:03:04.733
Итак, он будет искать "The" в начале

0:03:04.733,0:03:07.048
и будет возвращать 0, потому что именно там она находится.

0:03:08.063,0:03:12.000
Следующий вызов, вот этот, выдает 26

0:03:12.000,0:03:16.733
потому что index ищет точное значение

0:03:16.733,0:03:19.266
и он чувствителен к регистру

0:03:19.266,0:03:23.012
так что первое "The" не подходит, потому что Т заглавная

0:03:23.012,0:03:26.556
поэтому он будет искать другую "the" и здесь он найдет ее

0:03:26.787,0:03:30.953
Теперь, вы возможно думаете, что index ищет слово

0:03:30.953,0:03:34.236
но это не так, это только так выглядит

0:03:34.236,0:03:38.036
для подстроки, в которой символы идут один за другим

0:03:38.928,0:03:41.266
В следующем примере Вы можете увидеть

0:03:41.266,0:03:44.266
что мы ищем строку

0:03:44.266,0:03:47.599
c буквой "е" и пробелом после

0:03:47.599,0:03:49.332
и он возвратит нам 2

0:03:49.332,0:03:52.067
Здесь, как Вы можете видеть

0:03:52.067,0:03:55.937
выделены места, где "е" и пробел появляются

0:03:55.937,0:04:00.395
но, здесь есть "е ", как Вы уже наверное заметили,

0:04:00.395,0:04:05.457
таким образом, Мы можем достичь того, что index получит 3 параметр

0:04:05.457,0:04:11.401
здесь стоит число 3, но оно может быть любым другим числом

0:04:11.401,0:04:16.867
и он начнет поиск с третьей позиции

0:04:16.867,0:04:19.762
который, по существу, является 4 символом

0:04:19.762,0:04:22.867
потому что мы начинаем считать с 0

0:04:22.867,0:04:25.427
Итак, 3 пробел, пробел номер 3

0:04:25.427,0:04:29.420
и, следовательно, он найдет "the"  здесь,

0:04:29.420,0:04:35.261
в этом месте,которое по-видимому, 28 место

0:04:37.733,0:04:42.067
Аналогично, если я вызываю index и передам ему значение "e"

0:04:42.067,0:04:43.307
только, чтобы посмотреть

0:04:43.307,0:04:46.557
я задал цифру 3 начальной

0:04:46.557,0:04:49.800
тогда он найдет символ "е"

0:04:49.800,0:04:51.016
давайте посмотрим...

0:04:51.016,0:04:53.399
в слове "Jumped"

0:04:53.399,0:04:55.333
здесь, есть символ "e",

0:04:55.333,0:04:57.702
то что будет искаться

0:04:57.702,0:05:00.350
очевидно, что вместо 3 здесь может быть любое число

0:05:00.350,0:05:01.928
так, если я начну с 5

0:05:01.928,0:05:04.466
и он возвратит то же значение

0:05:04.466,0:05:06.666
давайте запустим этот скрипт

0:05:06.666,0:05:10.000
Итак, мы можем увидеть что возвращенные величины равны:

0:05:10.000,0:05:15.838
10, -1, 0, 26, 2, 28, 18

0:05:15.838,0:05:17.681
это то же значение

0:05:17.681,0:05:19.807
и неважно где точно Вы начинаете

0:05:19.807,0:05:21.415
если это происходит перед 

0:05:21.415,0:05:24.477
первым появлением подстроки

0:05:24.846,0:05:27.132
И это именно то что делает index

0:05:27.132,0:05:31.132
но так же есть функция, называемая rindex

0:05:31.132,0:05:32.394
которая делает тоже самое, только

0:05:32.394,0:05:33.973
начиная с правой стороны

0:05:33.973,0:05:35.690
это интересно

0:05:35.690,0:05:38.430
если на строке значение попадется несколько раз

0:05:38.430,0:05:42.461
и функция найдет самую правую из них

0:05:42.984,0:05:45.187
запуская rindex на той же строке

0:05:45.187,0:05:47.649
и передаем подстроку "e"

0:05:47.649,0:05:49.507
она возвратит нам 39

0:05:49.507,0:05:53.333
потому что найдет эту букву "e"

0:05:53.333,0:05:56.216
Так же rindex может иметь третий параметр

0:05:56.216,0:05:58.386
он будет сообщать откуда начинать

0:05:58.386,0:06:01.902
позицию, с которой начинать поиск

0:06:01.902,0:06:03.666
Итак, я сделал ее 38.

0:06:03.666,0:06:06.666
и функция найдет букву "e" здесь

0:06:06.666,0:06:07.951
возвращая 38

0:06:07.951,0:06:11.009
и если я начну с 37 здесь

0:06:11.009,0:06:15.533
тогда он возможно найдет "e", возвращая 33

0:06:15.533,0:06:17.346
Итак, это об index

0:06:17.346,0:06:20.552
Последняя функция, возможно, самая интересная

0:06:20.552,0:06:22.533
из всех функций, которые я сейчас показал,

0:06:22.533,0:06:23.878
это substring

0:06:24.800,0:06:27.800
Substring, на самом деле, противоположность index

0:06:27.800,0:06:31.882
Используя index, мы знаем что мы ищем

0:06:31.882,0:06:33.182
Какую строку мы ищем

0:06:33.182,0:06:34.670
только не зная гда она

0:06:34.670,0:06:36.295
Итак, мы ищем место.

0:06:36.295,0:06:38.478
Используя substring, мы знаем место

0:06:38.478,0:06:40.288
но мы не знаем что там

0:06:40.288,0:06:42.547
и мы хотим узнать это

0:06:42.547,0:06:45.699
Substring принимает строку в качестве аргумента,

0:06:45.699,0:06:48.531
опять, "The black cat climbed the green tree";

0:06:48.531,0:06:51.713
Число, которое является индикатором, итак, это место

0:06:51.713,0:06:54.266
с которого substring начнет поиск

0:06:54.266,0:06:56.379
в нашем предложении

0:06:56.379,0:07:01.348
Снова число 0 указывает на первый символ

0:07:01.348,0:07:06.156
и 4 символом является "b"

0:07:06.156,0:07:09.685
и третий параметр - длина

0:07:09.685,0:07:11.588
сообщения, которое мы ищем

0:07:11.588,0:07:13.423
Итак, длина - 5 символов

0:07:13.423,0:07:16.557
Функция возвращает 5 символов, начинающихся с буквы "b"

0:07:16.557,0:07:20.413
получаем слово "black"

0:07:20.413,0:07:22.733
Substring возвращает те значения

0:07:22.733,0:07:24.553
и, очевидно, я могу назначить их ...

0:07:24.737,0:07:31.233
то что я показал Вам на примерах функций lc и index

0:07:31.233,0:07:34.158
Вы можете присвоить это значение какой-то переменной

0:07:34.158,0:07:38.432
здесь тоже, я немного ленивый и потому сразу напишу результат

0:07:38.432,0:07:42.507
Этот вызов возвращает слово "black"

0:07:43.261,0:07:46.067
В следующем примере вы можете видеть

0:07:46.067,0:07:49.437
что длина может быть отрицательным числом

0:07:49.437,0:07:51.733
Как отрицательное число может быть здесь использовано?

0:07:51.733,0:07:56.449
Вместо использования реальной длины

0:07:56.449,0:08:00.675
Perl думает, что "4" означает

0:08:00.675,0:08:03.415
сколько символов слева оставить

0:08:03.415,0:08:05.180
и это число говорит

0:08:05.180,0:08:08.333
сколько символов справа не включать в себя

0:08:08.333,0:08:12.067
Итак, функция отсчитывает 4 символа слева

0:08:12.067,0:08:14.446
и 11 справа

0:08:14.446,0:08:15.924
а также все, что находится в середине

0:08:15.924,0:08:17.394
это то что я хотел получить

0:08:17.394,0:08:22.920
таким образом, мы получили "black cat climbed the"

0:08:22.920,0:08:26.274
Вы даже можете не назначать 3 параметр

0:08:26.666,0:08:30.127
что будет означать:

0:08:30.127,0:08:34.793
возврати мне строку начиная с 14 символа и до конца

0:08:34.793,0:08:38.326
потому что я не вижу насколько она длинная

0:08:38.326,0:08:42.461
то есть, от указателя до конца

0:08:42.461,0:08:44.594
Как вы можете видеть,

0:08:44.594,0:08:47.527
что даже первый параметр

0:08:47.527,0:08:49.394
может быть отрицательным числом

0:08:49.394,0:08:51.726
а это, как вы, наверное, догадались,

0:08:51.726,0:08:53.660
считает от конца

0:08:53.660,0:08:57.594
Итак, вместо того чтобы указать что длина менее 4

0:08:57.594,0:08:59.793
мы просто указываем менее 4

0:08:59.793,0:09:03.994
и это означает: начать с этой позиции

0:09:03.994,0:09:06.994
В этом примере

0:09:06.994,0:09:09.793
я не задал число символов

0:09:09.793,0:09:12.860
Итак,оно выдаст мне строку до конца

0:09:12.860,0:09:16.927
в этом случае, четыре буквы "tree"

0:09:16.927,0:09:19.860
Конечно, как показано в этом примере,

0:09:19.860,0:09:21.927
вы можете задать 3 параметр

0:09:21.927,0:09:23.660
и тогда оно возвратит вам

0:09:23.660,0:09:27.793
2 символа из 4 последних

0:09:27.793,0:09:29.394
то есть "TR"

0:09:29.394,0:09:31.927
Давайте просто запустим, и мы увидим

0:09:31.927,0:09:33.994
что "tr" здесь, правильно

0:09:33.994,0:09:36.326
и если я чуть-чуть изменю

0:09:36.326,0:09:40.193
для примера помещу "1" здесь

0:09:40.193,0:09:44.953
Затем запустим и мы получим только "t"

0:09:46.153,0:09:49.528
И если я задам "3" и запущу

0:09:49.528,0:09:54.395
Тогда я получу "tre", думаю вы поняли.

0:09:54.395,0:09:57.663
Последний пример выглядит немного иначе

0:09:57.663,0:10:00.462
до сих пор этот вызов возращал substring

0:10:00.462,0:10:05.995
но исходный $str, исходная строка не изменилась

0:10:05.995,0:10:10.263
В последнем примере, возвращенное значение то же

0:10:10.263,0:10:13.663ъ
оно определено первыми тремя параметрами

0:10:13.663,0:10:16.062
но в последнем примере

0:10:16.062,0:10:18.062
У нас также есть четвертый параметр

0:10:18.062,0:10:23.596
который, в этом случае, является строкой сожержащей "jumped from"

0:10:23.596,0:10:26.263
А происходит то, что в этом случае

0:10:26.263,0:10:31.663
функция substring преобразует строку

0:10:31.663,0:10:36.395
что было определено этими тремя параметрами

0:10:36.395,0:10:39.328
эта подстрока будет заменена новой строкой

0:10:39.328,0:10:47.524
Итак, поскольку здесь 14, 7 определяет слово "climbed"

0:10:50.432,0:10:55.796
возвращаемое значение в $z,будет "climbed"

0:10:55.796,0:10:59.796
но $str будет иметь другое содержание

0:10:59.796,0:11:04.796
и слово "climbed" будет заменено на "jumped from"

0:11:04.796,0:11:08.062
двумя словами

0:11:08.062,0:11:10.928
В этом случае $str будет содержать

0:11:10.928,0:11:13.596
"The black cat jumped from the green tree"

0:11:13.596,0:11:16.062
Как вы можете видеть, Perl не заботится 

0:11:16.062,0:11:20.328
о новой строке, новая подстрока, в действительности длиннее

0:11:20.328,0:11:22.328
чем исходная

0:11:22.328,0:11:25.062
Он просто делает достаточно места в строке

0:11:25.062,0:11:28.205
например

0:11:28.205,0:11:29.928
давайте запустим скрипт опять

0:11:29.928,0:11:31.482
итак, вы можете видеть, что

0:11:31.482,0:11:33.426
"The black cat jumped from the green tree"

0:11:33.426,0:11:34.513
он просто работает

0:11:34.513,0:11:38.882
Что случится, если я просто оставлю букву "j"

0:11:38.882,0:11:40.832
и запущу скрипт?Тогда мы увидим что

0:11:40.832,0:11:43.334
"The black cat j the green tree"

0:11:43.334,0:11:45.498
что бы это ни значило

0:11:45.498,0:11:49.565
Различия в длине строки не имеют значения

0:11:49.565,0:11:51.663
Вы даже можете указать пустую строку,

0:11:51.663,0:11:54.801
но она все равно есть здесь

0:11:54.801,0:11:59.339
и тогда Perl вырежет эту часть строки

0:11:59.367,0:12:01.196
оставив, в этом случае, 2 пробела,

0:12:01.196,0:12:04.062
потому что пробел стоит перед словом "climbed"

0:12:04.062,0:12:05.713
и после него

0:12:05.713,0:12:07.565
Итак, это о substring

0:12:07.565,0:12:09.247
Я надеюсь, вы научились чему-нибудь сегодня

0:12:09.247,0:12:11.165
и мы встретимся в следующей части

0:12:11.165,0:12:12.898
Если вы смотрите это видео на YouTube

0:12:12.898,0:12:15.196
пожалуйста, подпишитесь на канал

0:12:15.196,0:12:17.446
Спасибо Вам, и до свидания!
