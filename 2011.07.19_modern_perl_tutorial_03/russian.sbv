0:00:01.533,0:00:08.533
Привет, в этой части я хотел бы показать 
 вам как Perl сравнивает скалярные величины.

0:00:08.533,0:00:13.667
Попробуем сравнить 1 и 1.0 и 1.00

0:00:13.667,0:00:16.000
Одинаковы ли они? Может, одна из них больше или меньше остальных?

0:00:16.000,0:00:21.333
А что, если 1.00 является строкой, то есть написана в кавычках?

0:00:21.333,0:00:27.283
Что будет, если сравнить строки, например "foo" и "bar"?

0:00:27.283,0:00:29.283
Итак, в Perl-

0:00:29.283,0:00:34.282
Мы уже видели в Perl операторы "+" и ".", они переводят

0:00:34.282,0:00:39.282
строку в число и число в строку в зависимости от контекста.

0:00:39.282,0:00:44.282
И не важно какие значения вы присвоите переменным.

0:00:44.282,0:00:46.351
Это похоже на операторы.

0:00:46.351,0:00:50.258
В Perl есть два типа операторов сравнения.

0:00:50.258,0:01:00.239
В этой таблице вы можете видеть несколько операторов для
 сравнения чисел и несколько - для строк. 

0:01:00.239,0:01:04.076
Двойное равенство будет сравнивать обе части как числа.

0:01:04.076,0:01:07.333
Одно равенство будет сравнивать обе части как строки.

0:01:07.333,0:01:13.439
Этот оператор будет проверять на неравенство, 
 этот - меньше ли левое число правого.

0:01:13.439,0:01:16.936
А "lt" будет сравнивать их как строки. 

0:01:16.936,0:01:20.498
Давайте посмотрим как они работают.

0:01:20.498,0:01:22.398
Покажу на примере.

0:01:22.398,0:01:28.878
Давайте сравним 12 и 12.0. 

0:01:28.878,0:01:37.008
Если они равны - выведется TRUE. 

0:01:37.008,0:01:43.997
Иначе выведется FALSE.

0:01:43.997,0:01:49.208
Итак, запустив этот код я получу TRUE 
 так как 12 равно 12.0. 

0:01:49.208,0:01:54.200
Perl не придает значения ".0", так как

0:01:54.200,0:01:59.200
даже в таком виде число равно 12.

0:01:59.200,0:02:04.856
То же самое произойдет, если я поставлю два нуля, 
 это абсолютно не важно, я все еще получу истину.

0:02:04.856,0:02:09.945
Если я возьму число в кавычки, то я все равно получу истину 

0:02:09.945,0:02:14.945
потому что Perl сравнивает число со строкой.

0:02:14.945,0:02:19.467
Но если я сравню их при помощи оператора "eq" 

0:02:19.467,0:02:25.467
Я получу ложь, потому что Perl перевел число в строку.

0:02:25.467,0:02:31.892
То есть получается 12 слева и
 12.00 справа.

0:02:31.892,0:02:34.926
Две строки не идентичны как строки.

0:02:34.926,0:02:37.872
Как насчес сравнения чисел?

0:02:37.872,0:02:41.609
Какое из них больше, какое - меньше?

0:02:41.609,0:02:43.963
Давайте сравним два и три.

0:02:43.963,0:02:48.706
Очевидно, два меньше трех 
 и я получаю истину.

0:02:48.706,0:02:50.825
Итак, два меньше трех.

0:02:50.825,0:02:54.217
Что произойдет, если я сравню их как строки?

0:02:54.217,0:02:55.757
Результат тот же.

0:02:55.757,0:03:01.759
Все ещё истина, так как два стоит раньше трех в ASCII-таблице.

0:03:01.759,0:03:08.000
А что произойдет, если я сравню двенадцать и три?

0:03:08.000,0:03:10.267
Очевидно,

0:03:10.267,0:03:13.333
истина, так как двенадцать больше трех.

0:03:13.333,0:03:17.538
Но что получится, если я сравню их как строки оператором "gt"?

0:03:17.538,0:03:20.015
При запуске я получаю ложь.

0:03:20.015,0:03:24.221
Это может кого-то удивить, но если вдуматься в,

0:03:24.221,0:03:28.221
прицип работы операторов сравнения строк, то все станет ясно -   

0:03:28.221,0:03:32.221
они берут первый символ первой строки и

0:03:32.221,0:03:37.221
сравнивают его с первым символом второй строки.

0:03:37.221,0:03:40.069
И уже на этом этапе получается, что первый символ строки слева

0:03:40.069,0:03:44.069
стоит раньше в ASCII таблице первого символа правой строки.

0:03:44.069,0:03:55.968
И получается, что двенадцать как строка меньше трёх, и поэтому 
 выражение возвращает ложь.

0:03:55.968,0:04:02.139
А теперь я попробую сравнить “foo” и “bar.”

0:04:02.139,0:04:06.215
Я проверю их равенство при помощи оператора "==".

0:04:06.215,0:04:11.523
При запуске я неожиданно получаю истину.

0:04:11.523,0:04:16.864
Возможно, это не так неожиданно если вы знаете что произошло.

0:04:16.864,0:04:20.006
“==” сравнивает обе части как числа.

0:04:20.006,0:04:24.008
И из-за перевода в числа мы получаем эти предупреждения.

0:04:24.008,0:04:28.133
Из-за того, что “==” ожидает два числа.

0:04:28.133,0:04:34.267
Здесь у нас две строки, которые не являются 
 числами, поэтому Perl выдает предупреждения.

0:04:34.267,0:04:41.133
И переводит обе части в нули, так как  
 когда он обрабатывает строки, он ищет цифры.

0:04:41.133,0:04:47.013
В строках нет цифр, поэтому 
 они обе равны 0. 

0:04:47.013,0:04:54.933
А так как 0 равен 0 как число, то 
 Perl выводит TRUE.

0:04:54.933,0:05:04.018
Очевидно, что если вам нужно сравнить две переменные, 
 которые могут быть строками, лучше использовать “eq.”

0:05:04.018,0:05:12.016
На самом деле в большинстве случаев можно использовать “eq” 
 когда вы сравниваете две строки.

0:05:12.016,0:05:17.002
И в этом случае мы, конечно же, получаем ложь.

0:05:17.002,0:05:23.869
Интересно, что если одна из строк будет пустой, 
 то я столкнусь с той же проблемой и предупреждениями.

0:05:23.869,0:05:26.554
Я вновь получаю истину.

0:05:26.554,0:05:32.012
Напомню, я получил эти предупреждения 
 потому что хотел их получить.

0:05:32.012,0:05:41.996
Эта директива может быть довольно полезна, иначе 
 вы будете просто получать истину, что может удивить некоторых людей.

0:05:41.996,0:05:49.948
Очевидно, тут я тоже должен был использовать “eq”, 
 так как он возвращает ложь, как я и ожидал.

0:05:49.948,0:05:53.975
Теперь я покажу вам пример, с которым могут возникнуть проблемы.

0:05:53.975,0:06:08.806
Итак, я запрашиваю имя и получаю строку
 из командной строки.

0:06:08.806,0:06:23.384
Затем я вырезаю символ новой строки и 
 проверяю, что строка не равна 0.

0:06:23.384,0:06:30.762
И это распространённая ошибка, которую делают люди, 
 не знающие разницы между “eq” и “==.”

0:06:30.762,0:06:36.719
Если я напечатаю здесь какую-нибудь строку, я
 получу все эти предупреждения и истину.

0:06:36.719,0:06:41.635
Я проверял, пуста ли строка.

0:06:41.635,0:06:48.664
Это получается из-за того, что  “ddd” как 
 число равно нулю.

0:06:48.664,0:06:50.926
Двойное равенство переводит обе части в числа. 

0:06:50.926,0:06:53.005
Правая часть также равна нулю.

0:06:53.005,0:06:57.950
Поэтому обе части равны.

0:06:57.950,0:07:05.006
Правильно было бы проверить, не пуста ли строка
 с помощью "eq".

0:07:05.006,0:07:09.999
Итак, я запускаю программу, ввожу "ddd" и получаю ложь.

0:07:09.999,0:07:19.850
Также если я запущу программу и не введу ничего, то
 получу истину, так как строка пуста.

0:07:19.850,0:07:22.000
Это все, что я хотел рассказать про сравнение значений.

0:07:22.000,0:07:25.000
Спасибо за просмотр и до встречи.

