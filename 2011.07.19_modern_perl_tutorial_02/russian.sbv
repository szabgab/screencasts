0:00:00.919,0:00:02.660
Привет, и снова добро пожаловать на канал!

0:00:02.660,0:00:05.530
В этот раз я собираюсь рассказать о

0:00:05.530,0:00:08.060
структурах данных в Perl.

0:00:08.060,0:00:08.809
В частности, эта

0:00:08.809,0:00:11.989
презентация расскажет о скалярах.

0:00:11.989,0:00:16.669
Здесь вы видите Padre, среду разработки.
Это — её разрабатываемая версия.

0:00:16.669,0:00:21.309
Первое, что надо сделать — создать

0:00:21.309,0:00:22.920
сценарий Perl 5.

0:00:22.920,0:00:26.239
В нём уже есть самое необходимое, в том числе

0:00:26.239,0:00:28.949
операторы «use».

0:00:28.949,0:00:32.580
В Perl есть три вида

0:00:32.580,0:00:36.350
структур данных: скаляры, массивы и хэши.

0:00:36.350,0:00:38.499
Скаляры могут содержать

0:00:38.499,0:00:42.869
число или строку, строку с определённым значением
или ссылку на более сложную

0:00:42.869,0:00:44.910
структуру данных.

0:00:44.910,0:00:48.410
Об этом мы поговорим позже.

0:00:48.410,0:00:51.810
Каждая структура данных

0:00:51.810,0:00:54.060
имеет собственное обозначение,

0:00:54.060,0:00:55.379
которое мы называем сигилом.

0:00:55.379,0:00:58.850
Он является первым символом названия переменной.

0:00:58.850,0:01:03.550
Скаляры имеют знак доллара ($),
массивы — знак «собака» (@),

0:01:03.550,0:01:08.260
и хэши, также называемые словарями
или таблицами поиска,

0:01:08.260,0:01:10.960
имеют знак процента (%).

0:01:10.960,0:01:13.250
Теперь поговорим о скалярах.

0:01:13.250,0:01:17.799
Каждая скалярная переменная начинается
со знака доллара ($),

0:01:17.799,0:01:18.670
и лишь затем следуют

0:01:18.670,0:01:20.620
буквы, цифры

0:01:20.620,0:01:25.010
и знаки подчеркивания. Например, у вас
может быть такая переменная

0:01:25.010,0:01:26.390
или

0:01:26.390,0:01:28.020
определённое значение,

0:01:28.020,0:01:30.049
или можно указать

0:01:30.049,0:01:31.880
«длинное_название» (long_name),

0:01:31.880,0:01:35.509
состоящее из строчных букв

0:01:35.509,0:01:38.770
и знаков подчёркивания между словами,

0:01:38.770,0:01:42.040
или, как вариант:

0:01:42.040,0:01:46.160
«ЭтоДлинноеНазвание» (ThisIsALongName).

0:01:46.160,0:01:47.860
Такой стиль допустим, хотя

0:01:47.860,0:01:48.990
целое сообщество

0:01:48.990,0:01:54.229
предпочитает названия со всеми
строчными буквами

0:01:54.229,0:01:57.230
и знаками подчёркивания.

0:01:57.230,0:02:00.690
Поскольку используется оператор «use strict»,

0:02:00.690,0:02:05.439
вам будет нужно объявлять все переменные
с ключевым словом «my».

0:02:05.439,0:02:07.360
Итак, я объявляю переменную «my»,

0:02:07.360,0:02:08.719
«my $name»,

0:02:08.719,0:02:11.359
и задаю значение «foo».

0:02:11.359,0:02:14.319
Теперь я могу вывести... простите,

0:02:14.319,0:02:17.949
теперь я могу вывести содержимое переменной.

0:02:17.949,0:02:19.859
Если я сейчас нажму «F5»,

0:02:19.859,0:02:20.969
оно...

0:02:20.969,0:02:22.989
сначала я должен сохранить сценарий,

0:02:22.989,0:02:25.059
назову его просто — script.pl.

0:02:25.059,0:02:26.500
И тогда он

0:02:26.500,0:02:30.309
откроет отдельное окно, где
отобразит результат «foo».

0:02:30.309,0:02:34.680
Для этого мне и нужно это окно.

0:02:34.680,0:02:38.989
В общем, делается это так. Сначала мы
объявляем переменную с «my», и затем

0:02:38.989,0:02:40.260
придаём

0:02:40.260,0:02:43.379
этой переменной значение, которое можем вывести.

0:02:43.379,0:02:44.460
Не обязательно осуществлять

0:02:44.460,0:02:46.669
присвоение сразу. Мы можем

0:02:46.669,0:02:51.739
объявить переменную и позднее задать
её значение. Если я так сделаю,

0:02:51.739,0:02:55.109
я получу тот же результат.

0:02:55.109,0:02:59.699
Обычно предпочтительнее первый вариант.
Если логика кода позволяет,

0:02:59.699,0:03:01.709
вам стоит

0:03:01.709,0:03:05.689
сразу, при объявлении, присвоить значение.

0:03:05.689,0:03:10.189
Но это не всегда возможно. Бывают случаи,
когда вы должны

0:03:10.189,0:03:14.739
сначала объявить переменную, и потом уже
можно задать её значение.

0:03:14.739,0:03:16.779
Теперь посмотрим, что произойдёт,

0:03:16.779,0:03:20.159
если переменная не определена,

0:03:20.159,0:03:23.569
то есть, не имеет значения — я просто объявляю её.

0:03:23.569,0:03:26.579
Она содержит значение «undef».

0:03:26.579,0:03:31.649
Она не определена. Это как «NULL»...

0:03:31.649,0:03:32.649


0:03:32.649,0:03:36.509
Это как «NULL» в базах данных, но
ведёт себя несколько по-другому.

0:03:36.509,0:03:39.890
Например, мы можем проверить,

0:03:39.890,0:03:41.879
содержит ли переменная

0:03:41.879,0:03:46.339
какое-либо другое значение или только «undef».

0:03:46.339,0:03:52.859
Мы можем использовать ключевое слово «defined», чтобы
проверить, определена ли она, и вывести результат:

0:03:52.859,0:03:54.719
«say 'defined'»

0:03:54.719,0:03:57.459
«else»

0:03:57.459,0:04:00.159
«say 'no'»

0:04:00.159,0:04:01.920
И когда я запущу этот код,

0:04:01.920,0:04:03.649
вы увидите «no»,

0:04:03.649,0:04:06.369
а затем «foo».

0:04:06.369,0:04:08.999
С другой стороны, если я возьму тот же код

0:04:08.999,0:04:13.189
и помещу его и после присваивания,

0:04:13.189,0:04:15.709
вы увидите сначала результат «no»,

0:04:15.709,0:04:16.639
затем

0:04:16.639,0:04:19.039
программа пишет, что переменная определена,

0:04:19.039,0:04:20.259
и выводит

0:04:20.259,0:04:21.979
значение «foo», потому что

0:04:21.979,0:04:24.610
вывод значения происходит после

0:04:24.610,0:04:28.250
вывода «defined».

0:04:28.250,0:04:32.430
Итак, здесь видно, что значение ещё не задано,
здесь мы присваиваем значение, и

0:04:32.430,0:04:36.040
здесь переменная становится определённой.

0:04:36.040,0:04:38.990
Мы потом можем задать значение

0:04:38.990,0:04:43.490
«undef» заново. Например, здесь
можем указать, что «$name»

0:04:43.490,0:04:44.659
равна

0:04:44.659,0:04:46.479
«undef».

0:04:46.479,0:04:49.210
Я не буду копировать тот же самый код.

0:04:49.210,0:04:54.899
На этом этапе значение переменной снова «undef».

0:04:54.899,0:04:56.370
Переменные

0:04:56.370,0:04:59.319
могут содержать числа или строки

0:04:59.319,0:05:01.169
так что вы можете...

0:05:01.169,0:05:03.710
Давайте начнём с начала.

0:05:03.710,0:05:06.159
Вы можете объявить переменную, например,

0:05:06.159,0:05:09.030
«$x».

0:05:09.030,0:05:12.249
И задать в качестве её содержимого строку.

0:05:12.249,0:05:15.639
Затем у вас есть возможность вывести переменную.

0:05:15.639,0:05:19.210
А потом можно присвоить в качестве значения
той же переменной число,

0:05:19.210,0:05:21.800
и снова вывести её.

0:05:21.800,0:05:24.769
И если я запущу код, вы увидите, что

0:05:24.769,0:05:27.809
в начале это была строка, и затем — число.

0:05:27.809,0:05:30.529
Perl об этом не беспокоится. Perl не связывает

0:05:30.529,0:05:33.870
переменные с типами,

0:05:33.870,0:05:36.410
в нём нет ничего такого.

0:05:36.410,0:05:42.249
Так работают все операторы.

0:05:42.249,0:05:43.740
Работая с другими языками,

0:05:43.740,0:05:46.060
вы могли привыкнуть

0:05:46.060,0:05:47.199
к тому, что

0:05:47.199,0:05:50.610
с разными значениями, разными переменными,

0:05:50.610,0:05:52.559
связанными с типами переменных,

0:05:52.559,0:05:53.639
операторы

0:05:53.639,0:05:55.930
действуют по-разному.

0:05:55.930,0:05:57.099
В Perl

0:05:57.099,0:05:59.620
всё совсем по-другому.

0:05:59.620,0:06:01.960
Ни переменные,

0:06:01.960,0:06:03.599
ни операнды

0:06:03.599,0:06:06.230
не определяют, что будет делать оператор.

0:06:06.230,0:06:11.460
Здесь оператор решает, как поведут себя
операнды и переменные.

0:06:11.460,0:06:17.630
Так что я возьму другой пример.
Допустим, у меня есть переменная «$z»,

0:06:17.630,0:06:19.620
равная 3.

0:06:19.620,0:06:25.180
Я могу вывести её и взять другую переменную,

0:06:25.180,0:06:26.889
например, «$y»,

0:06:26.889,0:06:28.800
равную 4,

0:06:28.800,0:06:29.869
и затем

0:06:29.869,0:06:32.749
я тоже вывожу её.

0:06:32.749,0:06:37.030
Что нам дальше делать? Попробуем

0:06:37.030,0:06:40.400
взять «$z» и прибавить к ней «$y».

0:06:40.400,0:06:42.789
А затем попробуем

0:06:42.789,0:06:47.330
взять «$z»

0:06:47.330,0:06:50.919
и произведём конкатенация с «$y», так что

0:06:50.919,0:06:54.119
два значения будут сцеплены,

0:06:54.119,0:06:58.609
и третье, например —

0:06:58.609,0:07:00.480
«$z x $y», что будет умножением,

0:07:00.480,0:07:02.209
или...

0:07:02.209,0:07:08.210
вернее, повторением переменной, извините.

0:07:08.210,0:07:11.300
Итак, что мы получим, если я запущу код:

0:07:11.300,0:07:14.550
сначала он выведет два значения, 3 и 4.

0:07:14.550,0:07:15.879
Затем плюс

0:07:15.879,0:07:19.770
осуществит сложение чисел, которое возьмёт

0:07:19.770,0:07:25.379
значения двух скалярных переменных, 3 и 4,
и сложит их, как числа.

0:07:25.379,0:07:26.389
Точка

0:07:26.389,0:07:27.949
осуществляет конкатенацию.

0:07:27.949,0:07:29.639
Она возьмёт две строки,

0:07:29.639,0:07:33.249
попросту преобразует два числа в строки

0:07:33.249,0:07:34.709
и выведет

0:07:34.709,0:07:36.920
вместе тройку и четвёрку,

0:07:36.920,0:07:38.530
или 34, если

0:07:38.530,0:07:39.999
рассматривать это как число.

0:07:39.999,0:07:43.529
И последнее - оператор повторения.
Он берёт левую часть,

0:07:43.529,0:07:45.359
содержимое «$z»,

0:07:45.359,0:07:46.759
обрабатывает его как строку,

0:07:46.759,0:07:47.409
и затем

0:07:47.409,0:07:49.340
повторяет его

0:07:49.340,0:07:50.349
столько раз,

0:07:50.349,0:07:53.400
сколько указано в правой части.

0:07:53.400,0:07:56.189
Поскольку в левой части содержится строка «3»,

0:07:56.189,0:08:00.349
а правая часть содержит число 4,

0:08:00.349,0:08:03.210
он 4 раза выведет

0:08:03.210,0:08:05.499
символ «3».

0:08:05.499,0:08:06.870
Как вы видите,

0:08:06.870,0:08:08.159
здесь оператор —

0:08:08.159,0:08:09.789
то, что указывает

0:08:09.789,0:08:12.800
операндам, будут ли они вести себя как числа

0:08:12.800,0:08:15.499
или как строки.

0:08:15.499,0:08:17.069
Но что произойдёт, если

0:08:17.069,0:08:18.189
ни один из них

0:08:18.189,0:08:19.669
не будет числом?

0:08:19.669,0:08:22.460
Что произойдёт, если они

0:08:22.460,0:08:24.649
оба будут строками?

0:08:24.649,0:08:26.509
Если я сейчас запущу код,

0:08:26.509,0:08:28.729
мы увидим, что результат тот же,

0:08:28.729,0:08:30.740
посколько Perl автоматически преобразует

0:08:30.740,0:08:32.590
числа в строки

0:08:32.590,0:08:35.310
и строки в числа при необходимости,

0:08:35.310,0:08:38.260
если оператор этого требует.

0:08:38.260,0:08:41.480
Это нормально. А что происходит, если один из

0:08:41.480,0:08:42.850
операндов — строка,

0:08:42.850,0:08:46.860
а другой — число? Посмотрим, что произойдёт

0:08:46.860,0:08:48.370
в этом случае.

0:08:48.370,0:08:50.790
Я запускаю код, и получаю то же самое!

0:08:50.790,0:08:52.820
Perl об этом не волнуется.

0:08:52.820,0:08:54.590
Он автоматически преобразует

0:08:54.590,0:08:56.930
(или вручную, если вы захотите)

0:08:56.930,0:09:01.060
числа в строки или строки в числа, когда

0:09:01.060,0:09:03.750
это необходимо.

0:09:03.750,0:09:04.789
Всё в порядке,

0:09:04.789,0:09:06.300
в общем-то.

0:09:06.300,0:09:07.660
Но бывают другие случаи,

0:09:07.660,0:09:09.270
когда

0:09:09.270,0:09:11.220
это преобразование может не быть

0:09:11.220,0:09:13.600
стопроцентным. Итак,

0:09:13.600,0:09:16.960
что будет, если значение, например,

0:09:16.960,0:09:20.890
«3.14 is pi».

0:09:20.890,0:09:22.540
Между прочим,

0:09:22.540,0:09:27.090
это преобразование называется контекстом.

0:09:27.090,0:09:29.550
Причина, по которой

0:09:29.550,0:09:31.910
Perl преобразует числа, в том, что

0:09:31.910,0:09:35.140
Perl имеет контекст. Так, у нас есть
числовой контекст

0:09:35.140,0:09:37.290
и строковой контекст.

0:09:37.290,0:09:41.610
Числовой контекст и строковой контекст.

0:09:41.610,0:09:44.470
Я введу это здесь,

0:09:44.470,0:09:46.250
чтобы у вас не возникало сложностей из-за моего

0:09:46.250,0:09:48.260
произношения.

0:09:48.260,0:09:52.160
Короче, что произойдёт в этом случае.
У вас есть число 3

0:09:52.160,0:09:54.040
и строка, которая

0:09:54.040,0:09:56.209
не преобразуется в число

0:09:56.209,0:09:57.100
напрямую.

0:09:57.100,0:10:01.390
Что будет, если запущу этот код сейчас.

0:10:01.390,0:10:03.140
Возьмём, как есть.

0:10:03.140,0:10:06.870
Первое — цифра 3, как и должно быть.

0:10:06.870,0:10:10.670
Затем следует «3.14 is pi»,

0:10:10.670,0:10:14.910
это результат вывода содержимого «$y».

0:10:14.910,0:10:17.750
Затем я получаю это предупреждение

0:10:17.750,0:10:20.370
и результат «6.14».

0:10:20.370,0:10:25.350
Предупреждение появилось оттого,
что мы попытались использовать

0:10:25.350,0:10:26.520
эту строку

0:10:26.520,0:10:28.120
в числовом контексте

0:10:28.120,0:10:30.780
при сложении на строке..

0:10:30.780,0:10:33.250
Да, строке 12.

0:10:33.250,0:10:36.960
Вот она, эта строка. Теперь мы её видим.

0:10:36.960,0:10:42.210
Извините.

0:10:42.210,0:10:43.890
Да, вот это окно.

0:10:43.890,0:10:49.740
Вы можете видеть это здесь.

0:10:49.740,0:10:51.520
Вот строка, которая

0:10:51.520,0:10:53.820
была преобразована в число.

0:10:53.820,0:10:56.990
Мы получаем предупреждение.
Оно есть только потому, что мы

0:10:56.990,0:10:59.500
попросили выводить предупреждения.

0:10:59.500,0:11:03.260
Их использование важно, иначе может
незаметно совершиться

0:11:03.260,0:11:05.440
что-то, что вы, возможно, хотели,

0:11:05.440,0:11:08.750
но это будет означать наличие проблемы.

0:11:08.750,0:11:10.529
Сейчас это

0:11:10.529,0:11:12.860
«3.14 is pi»

0:11:12.860,0:11:17.030
Но при сложении на самом деле
было использовано только «3.14».

0:11:17.030,0:11:19.160
Вот что Perl делает:

0:11:19.160,0:11:21.440
берёт левую часть строки,

0:11:21.440,0:11:27.829
анализирует её и пытается использовать как число.

0:11:27.829,0:11:32.160
В этом смысл. Здесь есть пробел. Но он

0:11:32.160,0:11:35.249
останавливает преобразование.
Он не может быть преобразован в число.

0:11:35.249,0:11:38.750
С этого места дальнейшее значение не будет учтено.

0:11:38.750,0:11:40.430
По этой причине

0:11:40.430,0:11:41.940
Perl

0:11:41.940,0:11:44.809
использовал «3.14»

0:11:44.809,0:11:46.020
как значение

0:11:46.020,0:11:48.550
«$y» в этой операции сложения.

0:11:48.550,0:11:49.910
Вам, наверное,

0:11:49.910,0:11:52.620
интересно, что случилось с переменной «$y».

0:11:52.620,0:11:54.000
Была ли она сама преобразована?

0:11:54.000,0:11:55.579
Или только для использования

0:11:55.579,0:11:56.930
здесь, при сложении?

0:11:56.930,0:11:57.990
Как вы видите

0:11:57.990,0:11:59.300
в этой операции конкатенации,

0:11:59.300,0:12:00.110
здесь

0:12:00.110,0:12:03.519
мы получаем значение «3» из «$z»

0:12:03.519,0:12:06.530
и «3.14 is pi»

0:12:06.530,0:12:10.330
из переменной «$y». Как видно, «$y» не изменилась.

0:12:10.330,0:12:12.070
«$y» по-прежнему

0:12:12.070,0:12:14.010
та же строка.

0:12:14.010,0:12:15.970
А если вы посмотрите на третий пример,

0:12:15.970,0:12:18.370
вы заметите что это «$z»,

0:12:18.370,0:12:20.100
повторенная «$y» раз.

0:12:20.100,0:12:22.790
Вы могли ожидать, что получите

0:12:22.790,0:12:26.070
цифру «3» 3,14 раза, но

0:12:26.070,0:12:31.080
Perl не может это вывести...

0:12:31.080,0:12:32.870
Возможно вывести только

0:12:32.870,0:12:34.960
целые числа в данном случае...

0:12:34.960,0:12:36.200
Итак,

0:12:36.200,0:12:39.670
он преобразует «3.14» в «3» и использует это

0:12:39.670,0:12:41.590
для умножения...

0:12:41.590,0:12:42.880
для повторения.

0:12:42.880,0:12:44.920
Но вы не увидите повторного предупреждения,

0:12:44.920,0:12:47.360
как можно было ожидать.

0:12:47.360,0:12:49.040
Почему же?

0:12:49.040,0:12:50.190
Не потому ли,

0:12:50.190,0:12:53.190
что данная операция не генерирует предупреждение?

0:12:53.190,0:12:56.240
Давайте кликнем сюда и

0:12:56.240,0:12:58.100
закомментируем...

0:12:58.100,0:12:59.990
закомментируем этот участок кода

0:12:59.990,0:13:01.370
и запустим его снова.

0:13:01.370,0:13:02.870
Теперь вы

0:13:02.870,0:13:05.080
увидите, что предупреждение возникает

0:13:05.080,0:13:06.560
во время повторения.

0:13:06.560,0:13:09.010
Но ранее мы не получали

0:13:09.010,0:13:11.220
этого предупреждения.

0:13:11.220,0:13:15.350
А почему же? Потому что предупреждения
не было. А причина

0:13:15.350,0:13:17.120
в данный момент здесь.

0:13:17.120,0:13:19.530
Когда для операции сложения

0:13:19.530,0:13:21.940
Perl преобразовал

0:13:21.940,0:13:26.399
строку в число, это число было сохранено

0:13:26.399,0:13:27.920
в магическом месте

0:13:27.920,0:13:30.050
в «$y»

0:13:30.050,0:13:34.010
С этого момента у «$y» было, фактически,
два значения: значение строки и

0:13:34.010,0:13:35.310
числовое значение.

0:13:35.310,0:13:36.930
Это для того, чтобы

0:13:36.930,0:13:39.010
избежать преобразования в дальнейшем.

0:13:39.010,0:13:44.620
Когда мы дошли до этого места, чтобы
использовать оператор повторения,

0:13:44.620,0:13:46.209
у Perl больше не было необходимости
в преобразовании.

0:13:46.209,0:13:50.140
Потому не было причины возвращать предупреждение.

0:13:50.140,0:13:52.870
Вот так работает преобразование.

0:13:52.870,0:13:54.840
Теперь вы узнаете,

0:13:54.840,0:13:58.950
как действует преобразование чисел в строки.
Преобразование числа в строку

0:13:58.950,0:14:01.790
довольно просто. Получается то же

0:14:01.790,0:14:04.359
значение. Предположим, у вас есть число,
например, три.

0:14:04.359,0:14:08.060
И если вы посмотрите на него, как на строку,
это просто строка, символ «3»,

0:14:08.060,0:14:11.329
число «3». Но если у вас есть число,

0:14:11.329,0:14:15.369
строка, которая является числом «3.14».

0:14:15.369,0:14:19.150
Если бы у вас было только так,

0:14:19.150,0:14:24.310
и вы бы запустили это, предупреждения
бы не было, потому как это просто число.

0:14:24.310,0:14:29.140
Но поскольку мы имеем то, что
в действительности не является числом,

0:14:29.140,0:14:30.670
мы получаем предупреждение.

0:14:30.670,0:14:34.070
Ещё пара проблем, о которых стоит рассказать.

0:14:34.070,0:14:36.680
Одна из них — «undef».

0:14:36.680,0:14:39.560
Что же произойдёт с «undef» в том же контексте,

0:14:39.560,0:14:40.710
давайте посмотрим.

0:14:40.710,0:14:43.730
Допустим, в этом случае, здесь...

0:14:43.730,0:14:46.830
так...

0:14:46.830,0:14:48.369
«my $y».

0:14:48.369,0:14:51.750
Поскольку вы знаете, что она переменная
содержит «undef»,

0:14:51.750,0:14:53.150
я не буду выводить её.

0:14:53.150,0:14:57.020
Теперь у нас есть объявленная переменная

0:14:57.020,0:14:58.210
под названием «$z».

0:14:58.210,0:15:01.119
И объявленная переменная «$y», но мы

0:15:01.119,0:15:02.650
не присвоили ей значение.

0:15:02.650,0:15:05.020
Если я это запущу...

0:15:05.020,0:15:07.320
давайте закомментируем, нам это не нужно.

0:15:07.320,0:15:10.820
Теперь, если я запускаю этот код,
я получаю два предупреждения.

0:15:10.820,0:15:13.060
Использование неинициализированной...

0:15:13.060,0:15:16.290
Они говорят об использовании неинициализированных
значений. Это означает, что «$y»

0:15:16.290,0:15:21.800
содержала «undef» как при сложении,
так и при конкатенации.

0:15:21.800,0:15:26.490
Из этого видно, что

0:15:26.490,0:15:29.810
Perl возвращает предупреждения, когда
я пытаюсь использовать

0:15:29.810,0:15:32.520
неопределённые переменные,

0:15:32.520,0:15:34.020
как в числовом

0:15:34.020,0:15:37.640
контексте, так и в строковом.

0:15:37.640,0:15:39.740
Как вы можете видеть,

0:15:39.740,0:15:42.470
хоть это и сложно,

0:15:42.470,0:15:44.850
первый «say» выводит «3».

0:15:44.850,0:15:45.670
Затем этот

0:15:45.670,0:15:47.449
«say» снова выводит «3»,

0:15:47.449,0:15:50.420
потому что «$y», несмотря на содержание «undef»,

0:15:50.420,0:15:52.390
в числовом контексте

0:15:52.390,0:15:54.270
ведёт себя как 0.

0:15:54.270,0:15:57.910
А при конкатенации я снова получаю «3»,

0:15:57.910,0:16:00.540
потому что, хоть «$y» и «undef»,

0:16:00.540,0:16:05.670
в строковом контесте она ведёт себя,
как пустая строка.

0:16:05.670,0:16:09.520
Если вы хотите убедиться, что она

0:16:09.520,0:16:15.070
всё ещё «undef», тогда 

0:16:15.070,0:16:17.490
«print 'defined'»

0:16:17.490,0:16:20.760
и «else».

0:16:20.760,0:16:22.870
Извините, тут должно быть «say».

0:16:22.870,0:16:25.810
«not»

0:16:25.810,0:16:28.940
Да, это показывает, что я тут старожил.

0:16:28.940,0:16:31.330
Итак,

0:16:31.330,0:16:32.579
я запускаю этот код.

0:16:32.579,0:16:36.260
И вы видите «not». Переменная не определена.
Значит, несмотря на то,

0:16:36.260,0:16:40.730
что Perl использовал эту переменную

0:16:40.730,0:16:42.459
как в числовом, так и в строковом контексте,

0:16:42.459,0:16:45.420
он не изменил переменную.
Она по-прежнему не определена.

0:16:45.420,0:16:47.749
Это одна из вещей, которые я хотел показать.

0:16:47.749,0:16:49.520
Другая вещь —

0:16:49.520,0:16:52.180
то, что некоторым людям по убеждению

0:16:52.180,0:16:56.720
не нравится идея с предупреждениями.
Они предпочитают

0:16:56.720,0:16:57.660
исключения,

0:16:57.660,0:17:01.000
когда хоть что-то идёт неверно или немного не так.

0:17:01.000,0:17:02.459
Что они могут сделать —

0:17:02.459,0:17:08.990
превратить предупреждения в исключения.
Здесь они могут написать «FATAL».

0:17:08.990,0:17:13.189
А здесь, допустим, «=> all». Это превратит
каждое предупреждение

0:17:13.189,0:17:15.680
в фатальное исключение.

0:17:15.680,0:17:17.920
Если я перейду сюда и

0:17:17.920,0:17:19.790
верну это обратно...

0:17:19.790,0:17:20.850
вот так.

0:17:20.850,0:17:22.640
Запускаю код.

0:17:22.640,0:17:25.189
Я получаю «3»,

0:17:25.189,0:17:26.890
первый вывод,

0:17:26.890,0:17:28.419
первый «say» здесь.

0:17:28.419,0:17:31.759
И когда я пытаюсь сложить значения,

0:17:31.759,0:17:35.649
я могу получить предупреждение, но теперь
это — фатальное исключение.

0:17:35.649,0:17:37.840
Поэтому сценарий

0:17:37.840,0:17:40.380
прекращает выполнение.

0:17:40.380,0:17:43.930
Это правильно, если вы хотите быть экстремалом

0:17:43.930,0:17:46.020
и получать исключения даже в таких случаях.

0:17:46.020,0:17:49.059
Но если вы хотите избежать этого? Что, если вы

0:17:49.059,0:17:51.720
желаете убедиться, что значение,

0:17:51.720,0:17:55.410
возможно, полученное от пользователя
или внешней среды,

0:17:55.410,0:17:57.010
действительно

0:17:57.010,0:17:59.910
является числом, прежде чем вы

0:17:59.910,0:18:00.950
преобразуете его?

0:18:00.950,0:18:04.610
Для этого вы можете использовать модуль:

0:18:04.610,0:18:07.510
«use Scalar::Util».

0:18:07.510,0:18:09.230
Этот модуль

0:18:09.230,0:18:12.669
имеет функцию под названием

0:18:12.669,0:18:15.650
«looks_like_number».

0:18:15.650,0:18:20.400
Вы можете использовать эту функцию,
прежде чем перейти

0:18:20.400,0:18:23.419
к части, требующей числа.

0:18:23.419,0:18:26.620
Для этого вы могли бы использовать

0:18:26.620,0:18:31.380
«looks_like_number($z)»

0:18:31.380,0:18:32.340
и

0:18:32.340,0:18:37.900
«looks_like_number($y)»,

0:18:37.900,0:18:44.770
И только тогда выполнять ту часть.

0:18:44.770,0:18:49.400
Так, я бы выполнил сложение только если
обе переменные содержат числа.

0:18:49.400,0:18:51.390
Теперь я запускаю этот код

0:18:51.390,0:18:53.900
и натыкаюсь на синтаксическую ошибку.

0:18:53.900,0:18:55.050
Посмотрим, где же.

0:18:55.050,0:18:56.650
Строка 15.

0:18:56.650,0:18:58.930
Согласно сообщению, я забыл

0:18:58.930,0:19:01.120
закрыть скобки.

0:19:01.120,0:19:02.450
Запустим ещё раз.

0:19:02.450,0:19:06.120
Теперь вы можете видеть, тут у меня
число «3» и результат

0:19:06.120,0:19:10.390
конкатенации, а также «defined».

0:19:10.390,0:19:12.420
Но я не получаю исключений.

0:19:12.420,0:19:14.320
А если тут будет

0:19:14.320,0:19:16.710
значение надопобие этого,

0:19:16.710,0:19:18.170
значение, которое действительно

0:19:18.170,0:19:20.000
является числом, и я запущу код,

0:19:20.000,0:19:27.000
то, помимо конкатенации, будет выполнено и сложение.

0:19:27.200,0:19:28.129
Это всё

0:19:28.129,0:19:31.799
по поводу скаляров. Если вам интересно, есть ли

0:19:31.799,0:19:34.480
перегрузка операторов в Perl — она есть.

0:19:34.480,0:19:38.080
Но это тема для продвинутых, и я
не буду сейчас обращаться к ней.

0:19:38.080,0:19:41.240
Я думаю, это всё. До встречи в следующий раз!
