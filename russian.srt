1
0:00:03,700 --> 0:00:06,190
Привет снова.

2
0:00:06,190 --> 0:00:09,070
Сегодня я расскажу о
встроенном отладчике

3
0:00:09,070 --> 0:00:11,309
перла.

4
0:00:11,309 --> 0:00:14,089
Обычно, если у нас есть скрипт

5
0:00:14,089 --> 0:00:16,350
В этом случае это 'outline.pl'

6
0:00:16,350 --> 0:00:21,569
Его можно запустить из командной строки так:
perl, имя скрипта и возможные параметры.

7
0:00:21,569 --> 0:00:23,960
Давайте попробуем запустить этот скрипт.

8
0:00:23,960 --> 0:00:25,599
Мы видим, что он что-то выводит.

9
0:00:25,599 --> 0:00:29,849
Отладить его можно с помощью команды
perl -d, 

10
0:00:29,849 --> 0:00:33,120
имя скрипта,
и затем параметры.

11
0:00:33,120 --> 0:00:33,770
Так.

12
0:00:33,770 --> 0:00:36,240
Я запустил его,

13
0:00:36,240 --> 0:00:38,920
он нам кое-что вывел.

14
0:00:38,920 --> 0:00:43,340
Отобразил первую строку кода,
и следущую строку, которая

15
0:00:43,340 --> 0:00:45,010
должна выполниться,

16
0:00:45,010 --> 0:00:47,220
а также приглашение для
работы с отладчиком,

17
0:00:47,220 --> 0:00:50,290
где я могу выполнять разные
его команды.

18
0:00:50,290 --> 0:00:51,839
Первая и самая важная -

19
0:00:51,839 --> 0:00:52,610
это 'q',

20
0:00:52,610 --> 0:00:54,960
которая позволит нам выйти
из отладчика.

21
0:00:54,960 --> 0:00:58,000
Так что когда мы хотим
избавиться от него,

22
0:00:58,000 --> 0:00:58,689
мы нажимаем

23
0:00:58,689 --> 0:01:00,950
q и enter, и выходим из него.

24
0:01:00,950 --> 0:01:02,820
Давайте запустим отладчик снова.

25
0:01:02,820 --> 0:01:04,840
Следущая по значимости команда -

26
0:01:04,840 --> 0:01:06,420
это 'h'.

27
0:01:06,420 --> 0:01:08,390
Предоставляет нам помощь.

28
0:01:08,390 --> 0:01:12,100
Мы видим здесь разные опции.
Это только краткий список

29
0:01:12,100 --> 0:01:13,840
отладчика.

30
0:01:13,840 --> 0:01:18,110
Так что вы знаете, что у вас
есть много возможностей

31
0:01:18,110 --> 0:01:20,800
и способов использования отладчика.

32
0:01:20,800 --> 0:01:24,520
Чтобы увидеть код снова,

33
0:01:24,520 --> 0:01:25,530
я нажимаю 'l',

34
0:01:25,530 --> 0:01:29,120
что предоставляет нам
весь код.

35
0:01:29,120 --> 0:01:30,400
И в выводе 'l'

36
0:01:30,400 --> 0:01:33,660
мы видим номера строк,

37
0:01:33,660 --> 0:01:35,830
а эта стрелка указывает на строку,

38
0:01:35,830 --> 0:01:39,260
которая исполнится следущей. То есть эта

39
0:01:39,260 --> 0:01:40,240
строка еще не выполнилась.

40
0:01:40,240 --> 0:01:43,690
Если я хочу посмотреть, что в
переменной $file,

41
0:01:43,690 --> 0:01:45,430
которая на самом

42
0:01:45,430 --> 0:01:47,100
деле должна быть пустой,

43
0:01:47,100 --> 0:01:49,750
я могу использовать команду

44
0:01:49,750 --> 0:01:52,720
'p' - 'вывести'.

45
0:01:52,720 --> 0:01:54,799
Я пишу 'p имя_переменной', и мне

46
0:01:54,799 --> 0:01:56,799
ничего не выводится.

47
0:01:56,799 --> 0:01:59,269
На самом деле я могу даже узнать,

48
0:01:59,269 --> 0:02:02,720
определена она или нет.

49
0:02:02,720 --> 0:02:05,750
Я могу написать p defined и отладчик

50
0:02:05,750 --> 0:02:06,869
вернет ложь,

51
0:02:06,869 --> 0:02:08,499

52
0:02:08,499 --> 0:02:10,419
то есть опять не выведет ничего.

53
0:02:10,419 --> 0:02:14,299
Можно попробовать сделать
посложнее, использовать

54
0:02:14,299 --> 0:02:18,680
not defined и отладчик выведет
какое-нибудь истинное значение.

55
0:02:18,680 --> 0:02:20,180
Далее.

56
0:02:20,180 --> 0:02:24,670
Посмотрим, как я могу исполнить эти строки.

57
0:02:24,670 --> 0:02:26,959
Я хочу вернуться в эту точку и

58
0:02:26,959 --> 0:02:29,219
выполнить эту строку кода.

59
0:02:29,219 --> 0:02:33,729
Чтобы совершить данную операцию, я
пишу 's', что значит 'сделать шаг',

60
0:02:33,729 --> 0:02:35,669
и нажимаю enter.

61
0:02:35,669 --> 0:02:39,560
Выполнится эта строка кода и
выведется следущая,

62
0:02:39,560 --> 0:02:41,269
которая будет исполнена.

63
0:02:41,269 --> 0:02:46,040
Если я отображу содержимое
переменной $file,

64
0:02:46,040 --> 0:02:49,140
мы увидим, что у нее уже есть
значение, которое было

65
0:02:49,140 --> 0:02:51,519
указано в командной строке.

66
0:02:51,519 --> 0:02:53,119
Теперь у меня есть

67
0:02:53,119 --> 0:02:54,519
эта информация,

68
0:02:54,519 --> 0:02:58,139
и я хочу выполнить следущую строку.

69
0:02:58,139 --> 0:03:01,379
В ней вызывается
функция slurp,

70
0:03:01,379 --> 0:03:04,180
которая идет из другого модуля.

71
0:03:04,180 --> 0:03:05,949
Нажимаю снова 's',

72
0:03:05,949 --> 0:03:06,939
выполнится

73
0:03:06,939 --> 0:03:08,619
следущая

74
0:03:08,619 --> 0:03:09,499
часть кода,

75
0:03:09,499 --> 0:03:11,999
которая и правда
вызывает

76
0:03:11,999 --> 0:03:13,959
ту функцию.

77
0:03:13,959 --> 0:03:17,539
Мы здесь видим, что на этот раз

78
0:03:17,539 --> 0:03:19,200
он вывел первую

79
0:03:19,200 --> 0:03:19,839
строку,

80
0:03:19,839 --> 0:03:22,430
которая выполнится в другом файле.

81
0:03:22,430 --> 0:03:23,480
Тут мы видим:

82
0:03:23,480 --> 0:03:25,150
это - имя

83
0:03:25,150 --> 0:03:26,619
пакета,

84
0:03:26,619 --> 0:03:29,309
в котором код располагается,

85
0:03:29,309 --> 0:03:32,819
read_file - имя функции,
которая вызывается,
что немного странно,

86
0:03:32,819 --> 0:03:36,919
потому что мы вызвали
функцию slurp,

87
0:03:36,919 --> 0:03:38,270
а вместо этого

88
0:03:38,270 --> 0:03:38,990
исполняется read_file.

89
0:03:38,990 --> 0:03:40,950
И нам надо посмотреть, что

90
0:03:40,950 --> 0:03:44,559
там происходит. Это - имя файла,

91
0:03:44,559 --> 0:03:48,479
где находится функция read_file.

92
0:03:48,479 --> 0:03:51,010
И мы на строке 75.

93
0:03:51,010 --> 0:03:52,749
Это - строка,

94
0:03:52,749 --> 0:03:55,489
которая исполнится следущей.

95
0:03:55,489 --> 0:04:00,029
Осмотримся, то есть введем 'l'

96
0:04:00,029 --> 0:04:02,919
и диапазон номеров строк

97
0:04:02,919 --> 0:04:04,309
от 70 до 80.

98
0:04:04,309 --> 0:04:06,310
И отладчик отобразил нам строки

99
0:04:06,310 --> 0:04:08,119

100
0:04:08,119 --> 0:04:11,419
70-80 файла File/Slurp.pm .

101
0:04:11,419 --> 0:04:15,449
Здесь мы видим что мы в

102
0:04:15,449 --> 0:04:17,419
функции read_file,

103
0:04:17,419 --> 0:04:19,680
как и было сказано ранее,

104
0:04:19,680 --> 0:04:20,580
а выше

105
0:04:20,580 --> 0:04:25,340
мы видим, что функция slurp
является ссылкой на функцию read_file.

106
0:04:25,340 --> 0:04:28,650
Это объясняет, почему, когда
мы вызываем slurp,

107
0:04:28,650 --> 0:04:29,560
выполняется

108
0:04:29,560 --> 0:04:32,530
функция read_file.

109
0:04:32,530 --> 0:04:34,280
В функции read_file

110
0:04:34,280 --> 0:04:35,469

111
0:04:35,469 --> 0:04:37,850
эта строка выполнится следущей.

112
0:04:37,850 --> 0:04:39,750
Если я хочу продолжить,

113
0:04:39,750 --> 0:04:41,470
я могу снова нажать 's',

114
0:04:41,470 --> 0:04:44,280
но это не обязательно, потому что
если я просто

115
0:04:44,280 --> 0:04:47,949
нажму enter, исполнится
та же команда,

116
0:04:47,949 --> 0:04:51,690
что и в прошлый раз.

117
0:04:51,690 --> 0:04:55,389
Так я могу просто нажимать enter
и наблюдать, как программа выполняется

118
0:04:55,389 --> 0:04:56,830
шаг за шагом

119
0:04:56,830 --> 0:04:58,160
и проходить

120
0:04:58,160 --> 0:04:59,659
каждое значение

121
0:04:59,659 --> 0:05:03,110
каждую строку кода.

122
0:05:03,110 --> 0:05:07,499
Теперь мы понимаем, что это не
та функция, которую

123
0:05:07,499 --> 0:05:09,409
мы хотим отладить,

124
0:05:09,409 --> 0:05:10,539
поэтому лучше перепрыгнуть

125
0:05:10,539 --> 0:05:12,659
через нее.

126
0:05:12,659 --> 0:05:15,899
То есть мы зашли в эту функцию slurp,
решили, что нам не важно её содержимое,

127
0:05:15,899 --> 0:05:19,209
потому что знаем, что
проблема, которую ищем,

128
0:05:19,209 --> 0:05:20,069
находится не там,

129
0:05:20,069 --> 0:05:23,019
и хотели бы выйти из
этой функции,

130
0:05:23,019 --> 0:05:24,470
не проходя

131
0:05:24,470 --> 0:05:25,979
все строки

132
0:05:25,979 --> 0:05:31,490
шаг за шагом. Для этого
есть команда 'r'.

133
0:05:31,490 --> 0:05:32,949
Но прежде чем выполнить её,

134
0:05:32,949 --> 0:05:34,239
давайте сделаем что-нибудь еще.

135
0:05:34,239 --> 0:05:37,729
Выполним команду 'T',
она выводит стек.

136
0:05:37,729 --> 0:05:40,199
Так, когда я нажимаю 'T', вижу,

137
0:05:40,199 --> 0:05:41,789
где я

138
0:05:41,789 --> 0:05:46,019
в коде, и мы можем видеть, что
это - единственный вызов,

139
0:05:46,019 --> 0:05:48,280
который был сделан, то есть

140
0:05:48,280 --> 0:05:50,879
в стеке находится только одна функция.

141
0:05:50,879 --> 0:05:52,949
Нажатие 'r'

142
0:05:52,949 --> 0:05:55,979
вернет нас из текущей функции

143
0:05:55,979 --> 0:06:00,890
и выдаст её возвращаемое значение.
Поскольку в нашем случае возвращаемым значением

144
0:06:00,890 --> 0:06:04,249
является содержимое файла Padre.pm,

145
0:06:04,249 --> 0:06:06,540
мы здесь его видим,

146
0:06:06,540 --> 0:06:10,199
а точнее - его конец,
содержащий документацию

147
0:06:10,199 --> 0:06:13,620
и список людей,

148
0:06:13,620 --> 0:06:19,729
которые внесли вклад в проект Padre.
Кстати, спасибо им всем.

149
0:06:19,729 --> 0:06:21,320
Вернемся к коду.

150
0:06:21,320 --> 0:06:24,939
Здесь мы видим следущую
строку,

151
0:06:24,939 --> 0:06:26,930
которая исполнится.

152
0:06:26,930 --> 0:06:28,470
Это - вызов

153
0:06:28,470 --> 0:06:32,300
EditorTools, outline, new и определение

154
0:06:32,300 --> 0:06:33,399
функции.

155
0:06:33,399 --> 0:06:35,039


156
0:06:35,039 --> 0:06:40,099
Нажмем 's' снова
и зайдем в этот метод.

157
0:06:40,099 --> 0:06:42,180
Допустим, мы хотим посмотреть на строки

158
0:06:42,180 --> 0:06:46,680
с 45 по 60.

159
0:06:46,680 --> 0:06:49,059
Что мы здесь видим.

160
0:06:49,059 --> 0:06:52,050
Это - скорее всего пустые
строки, которые не выводятся.

161
0:06:52,050 --> 0:06:56,879
Мы сейчас в методе find,
на первой его строке.

162
0:06:56,879 --> 0:06:57,709
Совершим еще

163
0:06:57,709 --> 0:07:00,210
один шаг.

164
0:07:00,210 --> 0:07:02,010
На этот раз

165
0:07:02,010 --> 0:07:08,089
мы решаем, что нам без разницы, что
в proc_doc и не хотим туда заходить.

166
0:07:08,089 --> 0:07:09,409
Ранее, когда

167
0:07:09,409 --> 0:07:13,589
мы зашли в функцию slurp и
решили, что нам

168
0:07:13,589 --> 0:07:16,990
она не важна, мы пропустили
её, нажав 'r'.

169
0:07:16,990 --> 0:07:20,089
На этот раз я могу нажать 'n',

170
0:07:20,089 --> 0:07:21,719
что значит 'следущий шаг'.

171
0:07:21,719 --> 0:07:25,130
И если я нажму enter,

172
0:07:25,130 --> 0:07:27,999
выполнится код функции process_doc,

173
0:07:27,999 --> 0:07:31,130
но отладчик остановится

174
0:07:31,130 --> 0:07:32,120
на моменте

175
0:07:32,120 --> 0:07:33,360
сразу после

176
0:07:33,360 --> 0:07:34,909
вызова этой функции.

177
0:07:34,909 --> 0:07:38,069
Следущая строка - 53.

178
0:07:38,069 --> 0:07:40,620
Выше мы видим, что эта
строка

179
0:07:40,620 --> 0:07:42,130
исполнится следущей,

180
0:07:42,130 --> 0:07:43,839
а мы находимся здесь.

181
0:07:43,839 --> 0:07:45,750
Мы снова нажимаем enter,

182
0:07:45,750 --> 0:07:47,619
и это выполнит

183
0:07:47,619 --> 0:07:51,460
или 's', или 'n', что либо
перешагнет, либо сделает шаг,

184
0:07:51,460 --> 0:07:55,030
то есть то, что мы делали в прошлый раз.

185
0:07:55,030 --> 0:07:56,179
Так, если я нажму enter сейчас,

186
0:07:56,179 --> 0:07:58,270
отладчик перешагнет через

187
0:07:58,270 --> 0:08:01,419
вызов ppi

188
0:08:01,419 --> 0:08:02,800
и...

189
0:08:02,800 --> 0:08:06,750
Я думаю, на этот раз достаточно.
Возможно, позже я создам еще один

190
0:08:06,750 --> 0:08:08,770
урок об отладчике.

191
0:08:08,770 --> 0:08:14,629
Только не забывайте, что 'q' позволяет нам выйти.

192
0:08:14,629 --> 0:08:18,830
Кстати, если вам интересно почитать
об этом отладчике еще,

193
0:08:18,830 --> 0:08:23,529
есть одна замечательная книга,
давайте покажу. Вот эта.

194
0:08:23,529 --> 0:08:27,889
Рекомендую вам купить её и прочитать.

195
0:08:27,889 --> 0:08:30,830
Не я написал её.

196
0:08:30,830 --> 0:08:33,680
Вы можете почерпнуть из нее
много знаний.

197
0:08:33,680 --> 0:08:36,090
Итак, спасибо за просмотр,

198
0:08:36,090 --> 0:08:36,790
пока.
